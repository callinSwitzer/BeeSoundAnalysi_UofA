{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Susieâ€™s Bee Buzzing\"\nauthor: \"Callin Switzer\"\ndate: \"September 19, 2014\"\noutput: html_document\n---\n\n## Setup\n```{r setup}\n#rm(list = ls())\n#direct <- \"~/Desktop/SusieBuzz\"\n#setwd(direct)\n\n# install packages\nipak <- function(pkg){\n  new.pkg <- pkg[!(pkg %in% installed.packages()[, \"Package\"])]\n  if(length(new.pkg)) install.packages(new.pkg, dependencies = TRUE)\n  sapply(pkg, require, character.only = TRUE)\n}\n\npackages <- c(\"tuneR\", \"ggplot2\", \"compiler\", \"manipulate\", \"shiny\")\nipak(packages); rm(packages)\n\n\n#Since seewave, fftw, and rgl didn't install, I downloaded the source files, and \n#ran the seewave.r and fftw.r files on my computer, to give me the use of all\n#the functions.\nsource(\"~/Dropbox/DataAnalysisForOthers/SusieBuzz/Rpack/seewave/R/seewave.R\")\nsource(\"~/Dropbox/DataAnalysisForOthers/SusieBuzz/Rpack/fftw/R/fftw.R\")\n\n# set the player\nsetWavPlayer(\"afplay\")\n\n# global constant\nf <- 44100 # frequency of recordings\n\n##########################################\n###### FUNCTIONS\n##########################################\n## for the left channel\nfundReturn <- function (wave, f, wl = 512, ovlp = 0, fmax, threshold = NULL, \n                        from = NULL, to = NULL, plot = TRUE, xlab = \"Time (s)\", ylab = \"Frequency (kHz)\", \n                        ylim = c(0, fmax*2), pb = FALSE, ...) {\n  input <- inputw(wave = wave, f = f)\n  wave <- input$w\n  f <- input$f\n  rm(input)\n  if (!is.null(from) | !is.null(to)) {\n    if (is.null(from) && !is.null(to)) {\n      a <- 1\n      b <- round(to * f)\n    }\n    if (!is.null(from) && is.null(to)) {\n      a <- round(from * f)\n      b <- length(wave)\n    }\n    if (!is.null(from) && !is.null(to)) {\n      if (from > to) \n        stop(\"'from' cannot be superior to 'to'\")\n      if (from == 0) {\n        a <- 1\n      }\n      else {\n        a <- round(from * f)\n      }\n      b <- round(to * f)\n    }\n    wave <- as.matrix(wave[a:b, ])\n  }\n  if (!is.null(threshold)) {\n    wave <- afilter(wave = wave, f = f, threshold = threshold, \n                    plot = FALSE)\n  }\n  wave <- ifelse(wave == 0, yes = 1e-06, no = wave)\n  n <- nrow(wave)\n  p <- round(n/2)\n  step <- seq(1, n - wl, wl - (ovlp * wl/100))\n  N <- length(step)\n  WL <- wl%/%2\n  z1 <- matrix(data = numeric(wl * N), wl, N)\n  if (pb) {\n    pbar <- txtProgressBar(min = 0, max = n, style = 3)\n  }\n  for (i in step) {\n    z1[, which(step == i)] <- Re(fft(log(abs(fft(wave[i:(wl + \n                                                           i - 1), ]))), inverse = TRUE))\n    if (pb) {\n      setTxtProgressBar(pbar, i)\n    }\n  }\n  z2 <- z1[1:WL, ]\n  z <- ifelse(z2 == \"NaN\" | z2 == \"-Inf\", yes = 0, no = z2)\n  fmaxi <- f%/%fmax\n  tfund <- numeric(N)\n  for (k in 1:N) {\n    tfund[k] <- which.max(z[-c(1:fmaxi), k])\n  }\n  tfund <- as.numeric(ifelse(tfund == 1, yes = \"NA\", no = tfund))\n  ffund <- f/(tfund + fmaxi - 1)\n  x <- seq(0, n/f, length.out = N)\n  y <- ffund/1000\n  res <- cbind(x, y)\n  if (plot) {\n    plot(x = x, y = y, xaxs = \"i\", xlab = xlab, yaxs = \"i\", \n         ylab = ylab, ylim = ylim, las = 1, ...)\n    invisible(res)\n  }\n  else {\n    return(res)\n  }\n  if (pb) \n    close(pbar)\n  data.frame(x, y = y)\n}\n\nfundReturn <- cmpfun(fundReturn) # compile\n```\n\n## Analysis\n\n```{r analysis}\n##########################################\n###### ANALYSIS\n##########################################\n\n# read in .wav file\nw1 <- readWave(filename = \"W14_010.wav\")\n\n# look at oscillogram\noscillo(w1, f = f)\n\n# listen to whole wave\nlisten(w1, f)\n\n# return fundamental frequency over time\n# wl is the window length for sliding window -- 2048 seems pretty good to me.\n# ovlp is the % overlap for each window\nfund <- fundReturn(w1, f=f,wl = 2048, ovlp = 80, \n                       fmax = 1000, ylim = c(0, 0.5), type = \"l\") \n\n# calculates the mean before filtering the outliers out\nmean(fund$y)\nmod <- (lm(fund$y ~ 1)) # linear model for mean frequency\nabline(mod, lw = 2, col = 'red') # this fit isn't that great, before filtering\n\n# filter the fundamental frequency graph\n# get rid of points that aren't within 0.05 (50 Hz) of the main line\nfundFilter <- fund[abs(mod$residuals) < 0.05,]\n\n# show points that were filtered out with red stars\nplot(fund, type = \"p\", ylim = c(0,0.5), xlab = \"seconds\", ylab = \"Frequency (kHz)\", col = \"red\", pch = \"*\")\npoints(fundFilter, pch =16) # covers up the non-filtered points\n\n# plot a red line to show the average\nabline(h = mean(fundFilter$y), col = \"red\", lwd = 3)\n\n# calculate mean of newly filtered data\nmean(fundFilter$y) # answer in kHz\n\n# listen to a sin wave w/ frequency of \"freq\" for one second\nfreq <- mean(fundFilter$y)*1000 # this converts it to hz, so we can listen to it\nlisten(sine(freq))\n```\n\n\nlisten(sine(273))\n",
    "created" : 1481808722271.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4038631593",
    "id" : "B23AC6DF",
    "lastKnownWriteTime" : 1419739357,
    "last_content_update" : 1419739357,
    "path" : "~/Dropbox/dataAnalysisForOthers/SusieBuzz/susiebuzz.rmd",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}